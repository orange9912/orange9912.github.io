---
title: 深入浅出Vue笔记————虚拟DOM篇
date: 2021-10-20 14:24:45
tags:
categories:
- Vue
---

# 概述

Vue自从2.0版本开始引入了虚拟DOM技术，而虚拟DOM技术也是React的核心技术之一，引入了虚拟DOM之后，Vue的初始渲染速度提升了2～4倍。

虚拟DOM之所以称为虚拟DOM，是因为他不是真实的DOM，而是用JavaScript数据结构表示成的**虚拟节点树**，然后使用虚拟节点树进行渲染。

就是，先生成一个虚拟节点树，然后用它和上一次生成的虚拟节点树进行对比，只渲染不同的部分。

简单来说，就是**生成->对比->渲染**。

# 为什么引入虚拟DOM？

在前面一篇讲Vue的变化侦测的博客里，也提到过。React的变化侦测是比较暴力的，它不知道哪些地方需要变化，就只能通过虚拟DOM的比对，然后销毁、重建。

但其实在Vue中，Vue是知道哪些状态发生了变化的。Vue可以通过更细粒度的感知来更新视图，不需要进行比对。并且，Vue在更新DOM的时候是异步执行的：当侦听到数据变化，**Vue会开启一个队列，并且缓冲同一事件循环中发生的所有变更**。（当数据变化，会通知对应的所有依赖Watcher实例更新）当一个watcher被多次触发，只会被推入到队列一次，能够减少不必要的计算和DOM操作。在下一个的事件循环tick中，Vue刷新队列且执行实际（__已去重__）工作。

看起来并没有什么引入虚拟DOM的必要，性能上似乎也还好。但是这么设计有个代价，每个状态对应一个Watcher实例来观察，内存开销以及依赖追踪开销在大型项目之中非常的大。

于是，Vue2.0就选择了一个中等粒度的折中方案：**引入虚拟DOM**。把Watcher实例观察的级别从状态改成组件级别，也就是说当状态发生变化的时候，只能通知到组件级别。然后组件内部通过虚拟DOM去进行比对和渲染。

而且这个改动似乎也不大，因为前面的博客我们讲到，Watcher只是一个中介，调整外界到Watcher的粒度，应该是对响应式核心的改动不大。

# Vue中的虚拟DOM

在Vue之中，使用模板来描述状态和DOM的映射。Vue会通过模板编译，将模板转换成渲染函数，通过执行这个函数就能够得到一个虚拟节点树。

每次属性发生变化，会调用组件渲染函数**生成**新的虚拟节点树，然后将新生成的虚拟节点树与上一次渲染视图使用的旧虚拟节点树进行**对比**（**diff**），再把要更新的地方进行DOM操作（**patch**）。最后缓存这一次渲染视图使用的虚拟节点树的VNode

![流程](流程.png "VNode，即Virtual Node")

##  VNode

在虚拟DOM中，VNode即虚拟节点，在Vue中存在一个VNode类，用来实例化不同类型的vnode实例来表示不同类型的DOM节点。

```javascript
export default class VNode{
  constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory){
		this.tag = tag;
    this.data = data;
    this.children = children;
    ....
  }
  ...
}
```

VNode实际上就是一个JavaScript对象。在渲染视图之中，Vue会先创建VNode，然后再使用它去生成真实DOM，然后插入到页面渲染视图。

VNode的类型有以下几种：

- 注释节点
- 文本节点
- 元素节点
- 组件节点
- 函数式组件
- 克隆节点

## patch

patch算法又叫patching算法，它主要是通过对比新旧vnode找到需要更新的节点进行更新。本质上其实就是用JavaScript的运算速度换DOM操作的执行成本。

主要是两个算法：**patchVnode**和**updateChildren**。

patch算法的运行流程如下：

1. 检测oldVnode是否存在。若不存在，则使用vnode创建节点插入视图。存在则进入下一步
2. 检测oldVnode和vnode是否是同一个节点。如果是则使用patchVnode进行更详细的对比与更新操作。
3. 若第二步不是，则使用vnode创建真实节点并插入到视图中旧节点的旁边，并将视图中的旧节点删除

## patchVnode

 是同一个节点的情况下，会进入该算法进行更详细的对比和更新，patchVnode的算法流程大致如下：

1. 检测vnode与oldVnode是否完全一样？一样则退出，否则2
2. vnode和oldVnode是静态节点？是则退出，否则3
3. vnode有text属性？没有则代表是元素节点，有则检查oldVnode和vnode文本是否相同，不同就用vnode的文本替换真实DOM节点的内容否则4
4. 如果vnode和oldVnode都存在子节点，且子节点不相同，就进入updateChildren。否则进入567步逐个检测
5. 如果只有vnode子节点存在，则清空DOM中的文本并将vnode的子节点添加到DOM中。
6. 如果只有oldVnode存在子节点，则清空DOM中的子节点
7. 如果oldVnode中有文本，则清空DOM中的文本

总而言之，尽量vnode为准来更新视图。

## updateChildren

更新子节点，也是diff的核心。主要是4种操作：更新节点、新增节点、删除节点、移动节点。并且在循环中进行比对

1. 新增子节点。

   这个好理解，当没有在oldChildren中找到本次循环所指向的新子节点的节点，就新建一个节点插入到所有未处理节点的前面

2. 更新子节点。同一个节点且同一位置

3. 移动子节点。同一个节点，但是位置不同，则把需要移动的节点移动到所有未处理节点的前面。

4. 删除子节点。本质上是删除哪些oldChildren存在但newChildren不存在的节点。

为了实现两端向中间遍历（即分辨出哪些节点被处理过or未处理过），这里vue用了四个变量来计算已处理和未处理的节点，oldStartIdx、oldEndIdx、newStartIdx、newEndIdx。分别表示oldChildren开始位置的下标和结束位置的下标、newChildren开始位置的下标和结束位置的下标。

因为查找对应节点这个过程是通过循环，比较耗时，因此vue对这个过程做了个优化策略，**也就是双端对比**。同时从新旧children的两端开始比较，借助key值找到可复用的节点，再进行相关操作。

大概有四个快捷查找方式：

- 新前与旧前
- 新后与旧后
- 新后与旧前
- 新前与旧后

:::primary

新前指的是newChildren中所有未处理节点的第一个节点，新后指的是newChildren中所有未处理节点的最后一个节点。旧前与旧后以此类推

:::

其实就是顾名思义，先通过这四个快捷查找试探，如果找到了就不必循环查找，如果没找到才循环查找。

即通过对比新前/后与旧前/后位置的节点，看看是不是同一个节点，是则不用循环查找。这样可以减少移动节点的次数和减少不必要的性能损耗。

# 总结

虚拟DOM中最关键的部分就是patch。通过patch可以对比新旧两个虚拟DOM，并只针对发生了变化的节点进行更新视图的操作。

虚拟DOM也是React的核心技术之一。自从Vue2.0引入虚拟DOM后，初始渲染速度比Vue1.0提升了2～4倍，且大大降低了内存消耗。

# 参考资料

刘博文著的《深入浅出Vue.js》

[diff 算法深入一下？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/401340016)

[聊一聊Diff算法（React、Vue2.x、Vue3.x） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/149972619)


