---
title: 浏览器渲染过程
date: 2021-08-04 20:14:13
tags:
categories:
- 前端
---

前面也说过，当在浏览器上输入一个url，到页面加载出来，简单来说一共经历了这么几件事：

1. DNS查询

   其实就是将一个域名，解析成ip地址的一个过程，它会先去找缓存（比如说浏览器缓存->本机缓存(hosts文件)->路由器缓存）。找不到缓存的话，会跑去DNS服务器进行一个查询（具体怎么搞就不展开了），找到域名对应的ip地址之后，就进行第二步。

2. TCP连接

   对服务端的ip地址建立一个tcp连接，主要就是三次握手的过程。

3. HTTP请求

   发送一些请求来请求资源，最常见的就是请求html文档以及对应的图片、css等资源了。这个过程还涉及到一些浏览器缓存（会先看本地有无缓存、强缓存协商缓存之类的，以前的博客也有，不详细展开）

4. 服务器响应

5. 浏览器渲染

6. 最后还有个释放TCP连接

这篇笔记就是用于整理我从找到的各位大牛的知识文章加以整理得来的。

# 解析HTML文档，构建DOM树

当浏览器接收到一份文档的时候，它会去将这个文档的HTML标记进行一个处理、解析，从而将其转换为一颗DOM树。

# 获取外部资源，构建CSSOM树

一份文档里面通常还会去下载一些外部的样式表、或者外部的js代码，这个阶段之下，有一些需要注意的点。

1. 当浏览器遇到一个script标签时，会暂停构建DOM直到脚本执行完毕
2. JavaScript可以查询和修改DOM与CSSOM。
3. CSSOM构建时，会暂停执行JavaScript直到CSSOM构建完毕。

总结来说，总而言之两句话：**相比JavaScript资源，优先引入CSS。而且JavaScript尽可能少的影响DOM的构建。**

## CSS文件

**默认情况下，CSS会阻塞渲染，直到CSSOM树构建完毕。**这是因为CSSOM树不能以增量方式构建，css规则的特定性让他可以在各个不同的点相互覆盖，在所有规则解析、并构建完之前，浏览器不能知道每个元素的位置。

:::primary

CSSOM（CSS对象模型）是树形形式的所有css选择器和相关属性的映射，和DOM非常相似。

:::

也可以进行预加载，

```html
<link href='style.css' rel='preload'/>
```

preload属性值表示这份资源在页面加载完即可需要，它会在页面加载的生命周期早期阶段就开始获取，尽早的加载，减少阻塞。

## JavaScript文件

刚刚也提到，JavaScript文件会阻塞文档的解析直到执行完毕，**所以我们一般都会将js文件放在底部。**

当然，也有两种方法来改变这种阻塞的情况（只对外部js文件有效），分别是：defer和async

### defer

defer表示延迟执行引入的JS文件代码（**注意，是延迟执行，不是延迟加载**）。这使得加载这段JS文件时浏览器也未停止对HTML的解析，并行。当文档解析完毕后，按照顺序**执行**所有defer的脚本。

### async

async表示异步执行引入的JS文件。它和defer的区别主要是，async**如果加载完毕就立即执行**，这个执行的发生可能在解析过程或者解析过程之后。而且因为加载时间的不一，也无法保证异步脚本的执行顺序。

他们两种设置了之后都不会阻塞文档的解析。

:::primary

需要注意的是，js代码动态创建的script标签默认是异步加载的。

:::

# 合并DOM树和CSSOM树，构建渲染树

渲染树是两棵树的结合，表示将要渲染到页面上的所有内容。

# reflow、paint

拿到渲染树之后，浏览器将会根据这一棵渲染树，来计算布局和绘制，**这个过程就是reflow（重排/回流）和paint（绘制/重绘）。**

一般来说，每次涉及到元素宽度、高度等会影响到文档布局的修改，都会触发reflow和paint。

如果只是涉及到元素背景色、透明度等不影响文档布局的修改，就只会触发paint。

# 总结

浏览器渲染的过程主要有以下几点：

1. 处理HTML标签并构建DOM树
2. 处理CSS样式并构建CSSOM树
3. 将DOM与CSSOM合并成渲染树
4. 根据渲染树计算布局，reflow
5. 绘制，paint。

这几个步骤中，并不一定是按照顺序一次性完成的，在JS文件中可能涉及多次对DOM和CSSOM的修改，就可能会重复执行以上的步骤。

而且js文件会阻塞文档解析，css文件会阻塞文档渲染（因为需要构建CSSOM树）。

# 扩展：为什么提倡将CSS的引入放在head、js的引入放在body底部？

前面我们也说到，css文件会阻塞浏览器的渲染，而js文件会阻塞对文档的解析。

之所以会阻塞渲染，是因为加载css的时候，会等解析完毕生成CSSOM树才能够生成渲染树。

js文件加载、执行的过程中，这个时间一般是比较长的，而且可能文件本身比较大、一旦长期执行，就会一直阻塞HTML文档的解析，使得页面长时间白屏（性能指标的首屏时间），所以我们一般把js文件放在body底部。

而CSS文件放的位置不同，产生的效果也不同。

1. 如果把CSS文件放于head部分

   虽然在head标签引入时，会阻塞HTML的渲染，这个时候表现为短暂的白屏之后，出现带有完整样式的页面。这个过程只发生**一次解析渲染**：

   DOM树、CSSOM树并行解析->解析完毕合成渲染树->reflow->paint

2. 如果把CSS文件放于body部分，他会阻塞HTML的解析，但不阻塞HTML的渲染（**在css完成下载之前把引入标签之前的HTML先进行解析渲染，并展现，但没有样式**），然后下载解析完成之后，页面重新解析渲染。这个过程表现为：更加短暂的白屏时间，但先出现没有样式的文档（或者说裸奔），然后再展现完整样式。

   而这个过程会导致在后面重新解析渲染的过程中，多一次的reflow和paint，一般来说性能会相对较差，**所以我们多把CSS引入放于head处。**

